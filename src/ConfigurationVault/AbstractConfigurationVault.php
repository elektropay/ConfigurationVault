<?php

/*
 * This file is part of the UCSDMath package.
 *
 * (c) 2015-2017 UCSD Mathematics | Math Computing Support <mathhelp@math.ucsd.edu>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

declare(strict_types=1);

namespace UCSDMath\Configuration\ConfigurationVault;

use Hashids\Hashids;
use Hashids\HashidsInterface;
use UCSDMath\Filesystem\FilesystemInterface;
use UCSDMath\Serialization\Yaml\YamlInterface;
use UCSDMath\Configuration\ConfigurationVault\Exception\IOException;
use UCSDMath\Configuration\ConfigurationVault\Exception\VaultException;
use UCSDMath\Configuration\ConfigurationVault\Exception\FileNotFoundException;
use UCSDMath\Configuration\ConfigurationVault\ExtendedOperations\ServiceFunctions;
use UCSDMath\Configuration\ConfigurationVault\ExtendedOperations\ServiceFunctionsInterface;

/**
 * AbstractConfigurationVault provides an abstract base class implementation of {@link ConfigurationVaultInterface}.
 * This service groups a common code base implementation that ConfigurationVault extends.
 *
 * This component library is used to service configuration information outside of web root.
 *
 * This class was created to handle a security concern of placing clear text account
 * credentials (e.g., usernames, passwords) in PHP source control files within
 * the web root directory space.
 *
 * There are a few of rules I have tried to apply, these are:
 *    - IVs should be random and generated by a CSPRNG.
 *    - IVs should not be reused. That is, don't encrypt plaintext "A" and
 *      plaintext "B" with the same IV. Every record should have its own IV.
 *    - The IV is not a secret like the key. It can be stored in plaintext along
 *      with the cipher text. Although, I prefer to hide it with Hashids.
 *
 * This process involves moving some configuration settings outside the web document root
 * (e.g., /home/username/.external) and into a hidden directory. The owner of the files
 * will be the Apache user (e.g., chown -R apache:apache /home/username/.external), and
 * readable only by Apache (e.g., find /home/username/.external -type f -exec chmod 400 {} \;).
 * In addition, we encrypt the clear text data to make it harder to read.
 *
 * YAML is a human-readable data serialization format that works well with configuration
 * settings. The YAML syntax was designed to be easily mapped to complex data structures.
 * All configuration settings files will be YAML with the ConfigurationVaultInterface.
 *
 * @link http://en.wikipedia.org/wiki/YAML
 * @link http://www.yaml.org/spec/1.2/spec.html
 *
 * Method list: (+) @api, (-) protected or private visibility.
 *
 * (+) ConfigurationVaultInterface __construct(FilesystemInterface $filesystem, YamlInterface $yaml);
 * (+) void __destruct();
 * (+) bool exists($files);
 * (+) string decrypt(string $payload);
 * (+) string encrypt(string $payload);
 * (+) string getUniqueId(int $length = 16);
 * (+) string getRandomHex(int $length = 32);
 * (+) string reverseString(string $payload);
 * (+) string numberToString(string $payload);
 * (+) string stringToNumber(string $payload);
 * (+) string hashidsEncode($numerical = null);
 * (+) string repeatString(string $str, int $number);
 * (+) ConfigurationVaultInterface loadVaultSettingsFile();
 * (+) string getSha512(string $data = null, bool $isUpper = true);
 * (+) ConfigurationVaultInterface setEncryptionKey(string $encoded = null);
 * (+) ConfigurationVaultInterface setVaultFile(string $vaultFileDesignator);
 * (+) ConfigurationVaultInterface setHashidsProjectKey(string $optional = null);
 * (+) ConfigurationVaultInterface setInitializationVector(string $encoded = null);
 * (+) ConfigurationVaultInterface setOpenSslOption(int $option = \OPENSSL_RAW_DATA);
 * (+) ConfigurationVaultInterface unsetRegister(string $key, string $subkey = null);
 * (+) ConfigurationVaultInterface setAccountHomeDirectory(string $directoryPath = null);
 * (+) int getRandomInt(int $min = self::MIN_RANDOM_INT, int $max = self::MAX_RANDOM_INT);
 * (+) ConfigurationVaultInterface setEncryptionSettingsFileName(string $vaultFile = null);
 * (+) ConfigurationVaultInterface setVaultSettingsDirectory(string $directoryPath = null);
 * (+) ConfigurationVaultInterface setCipherMethod(string $method = self::DEFAULT_CIPHER_METHOD);
 * (+) ConfigurationVaultInterface setVaultRequestedSection(string $vaultRequestedSection = null);
 * (+) string decryptMessage(string $payload, string $encryptionKey, string $method = 'aes-256-cbc');
 * (+) string encryptMessage(string $payload, string $encryptionKey, string $method = 'aes-256-cbc');
 * (+) array hashidsDecode(string $id = null, int $starting = 0, int $minLength = self::DEFAULT_MIN_HASHIDS_LENGTH);
 * (+) ConfigurationVaultInterface openVaultFile(string $vaultFileDesignator, string $vaultRequestedSection = null);
 * (+) ConfigurationVaultInterface loadHashids(string $projectKey = null, int $minLength = self::DEFAULT_MIN_HASHIDS_LENGTH);
 * (+) ConfigurationVaultInterface setRecordProperties(string $vaultReleaseType, string $vaultEnvironment, string $vaultSection);
 * (-) bool isVaultRecordEncrypted()
 * (-) int stringSize(string $payload)
 * (-) Traversable toIterator($files)
 * (-) bool isReadable(string $filename)
 * (-) array renderAmbit(string $payload)
 * (-) ConfigurationVaultInterface setIvByteSize()
 * (-) ConfigurationVaultInterface setOpenSslVersion()
 * (-) ConfigurationVaultInterface setPrimaryHashArray()
 * (-) ConfigurationVaultInterface setCoreSeedHashArray()
 * (-) ConfigurationVaultInterface setRsaPublicPrivateKeys()
 * (-) ConfigurationVaultInterface setInitializationVectorArray()
 * (-) ConfigurationVaultInterface loadEncryptionSettingsRawData()
 * (-) string resizeKeyToMap(string $hash, array $specificMapSize)
 * (-) ConfigurationVaultInterface setVaultEnvironmentTypeSettings()
 * (-) ConfigurationVaultInterface setVaultRecordEncrypted($value = true)
 * (-) string randomToken(int $length = 32, string $chars = self::PASSWORD_TOKENS)
 * (-) ConfigurationVaultInterface setAvailableOpenSslDigests(bool $aliases = false)
 * (-) ConfigurationVaultInterface setAvailableOpenSslCipherMethods(bool $aliases = false)
 * (-) ConfigurationVaultInterface setVaultDataArguments(array $arguments, array $vaultData)
 * (-) ConfigurationVaultInterface setKeyByteSize(int $size = self::DEFAULT_ENCRYPTION_KEY_BYTE_SIZE)
 * (-) ConfigurationVaultInterface setByteSizeMap(string $keyType = 'ivByteSize', int $cipherMethodByteSize = null)
 *
 * @author Daryl Eisner <deisner@ucsd.edu>
 */
abstract class AbstractConfigurationVault implements ConfigurationVaultInterface, ServiceFunctionsInterface
{
    /**
     * Constants.
     *
     * @var string VERSION The version number
     *
     * @api
     */
    const VERSION = '1.13.0';

    //--------------------------------------------------------------------------

    /**
     * Properties.
     *
     * @var    YamlInterface               $yaml                          The Yaml Interface
     * @var    FilesystemInterface         $filesystem                    The Filesystem Interface
     * @var    HashidsInterface            $hashids                       The Hashids Interface
     * @var    string                      $accountHomeDirectory          The absolute path to the Account Home Directory (i.e., not document root)
     * @var    string                      $vaultSettingsDirectory        The absolute path to the Vault Settings Directory (i.e., a hidden location)
     * @var    string                      $encryptionSettingsFileName    The absolute path to the Encryption Settings Yaml File
     * @var    array                       $encryptionSettingsRawData     The raw Encryption Settings data
     * @var    string                      $hashidsProjectKey             The project key used to encode/decode Hashids integers and arrays
     * @var    string                      $openSslVersion                The OpenSSL version number installed on the system
     * @var    array                       $primaryHashArray              The primary list of hash strings used to encrypt/decrypt data
     * @var    array                       $coreSeedHashArray             The core seed list of hash strings used to encrypt/decrypt data
     * @var    array                       $initializationVectorArray     The initialization vector list of hash strings used to encrypt/decrypt data
     * @var    string                      $rsaPublicKey4096              The RSA public key used by the application
     * @var    string                      $rsaPrivateKey4096             The RSA private key used by the application
     * @var    array                       $availableOpenSslDigests       The list of available digests provided in the current version of PHP's OpenSSL (e.g.,'SHA1','SHA256','SHA512', etc.)
     * @var    array                       $availableOpenSslCipherMethods The list of available cipher methods provided in the current version of PHP's OpenSSL
     * @var    string                      $cipherMethod                  The cipher method used by OpenSSL to encrypt/decrypt a payload (e.g.,'AES-256-CTR','AES-256-GCM','AES-256-CCM', etc.)
     * @var    int                         $ivByteSize                    The size in bytes for the initialization vector (determined by the cipher method used)
     * @var    array                       $ivByteSizeMap                 The map that defines a base64 encoded format for $ivByteSize with padding
     * @var    int                         $keyByteSize                   The size in bytes for the encryption key (please size the cipher method used)
     * @var    array                       $keyByteSizeMap                The map that defines a base64 encoded format for $keyByteSize with padding
     * @var    array                       $defaultByteSizeMapTypes       The defined array of values used to whitelist options
     *
     * @var    string                      VAULTED[payload]               The data being processed
     * @var    string                      VAULTED[method]                The cipher method used by OpenSSL to encrypt/decrypt a payload (e.g.,'AES-256-CTR','AES-256-GCM','AES-256-CCM', etc.)
     * @var    string                      VAULTED[key]                   The properly sized encryption key used to encrypt/decrypt the payload (the key size is based on the cipher method/mode used)
     * @var    int                         VAULTED[option]                The bitwise disjunction used in OpenSSL (Default: 0, \OPENSSL_RAW_DATA: 1, \OPENSSL_ZERO_PADDING: 2)
     * @var    string                      VAULTED[iv]                    The fixed-size pseudorandom input primitive used in the encryption scheme (Raw binary: based on the method/mode used, AES-256-CTR)
     * @var    string                      VAULTED[dataSize]              The size of the data string within the payload
     * @var    string                      VAULTED[ivSalt]                The random number added in each IV
     * @var    string                      VAULTED[keySalt]               The salt used to create the encryption key
     *
     * @var    string                      $vaultFile                     The absolute path to the configuration settings file to access and open
     * @var    string                      $vaultRequestedSection         The requested section of the vault/settings file (e.g., 'webadmin', 'webuser', 'wwwdyn', etc.)
     * @var    array                       $resultDataSet                 The raw data from the specific vault file requested
     * @var    string                      $vaultReleaseType              The release collection type (e.g., 'database', 'account', 'smtp') as specified within the vault file
     * @var    string                      $vaultDefaultEnvironment       The default category environment (this class specific)
     * @var    string                      $vaultEnvironment              The current environment defined and used for a vault file (e.g., 'development', 'staging', 'production')
     * @var    string                      $vaultSection                  The specific section of the vault/settings file to be processed (e.g., 'webadmin', 'webuser', 'wwwdyn', etc.)
     * @var    string                      $vaultId                       The configuration settings id for the record in process
     * @var    string                      $vaultUuid                     The configuration settings uuid for the record in process
     * @var    string                      $vaultDate                     The configuration settings date for the record in process
     * @var    string                      $vaultIsEncrypted              The configuration settings is_encrypted for the record in process
     * @var    array                       $vaultEnvironments             The list of provided categories found in the configuration setting file
     * @var    string                      $vaultDefaultSection           The default section found in the configuration setting file
     * @static ConfigurationVaultInterface $instance                      The static instance ConfigurationVaultInterface
     * @static int                         $objectCount                   The static count of ConfigurationVaultInterface
     * @var    array                       $storageRegister               The stored set of data structures used by this class
     */
    protected $yaml                          = null;
    protected $filesystem                    = null;
    protected $hashids                       = null;
    protected $accountHomeDirectory          = null;
    protected $vaultSettingsDirectory        = null;
    protected $encryptionSettingsFileName    = null;
    protected $encryptionSettingsRawData     = [];
    protected $hashidsProjectKey             = null;
    protected $openSslVersion                = null;
    protected $primaryHashArray              = [];
    protected $coreSeedHashArray             = [];
    protected $initializationVectorArray     = [];
    protected $rsaPublicKey4096              = null;
    protected $rsaPrivateKey4096             = null;
    protected $availableOpenSslDigests       = [];
    protected $availableOpenSslCipherMethods = [];
    protected $cipherMethod                  = null;
    protected $ivByteSize                    = null;
    protected $ivByteSizeMap                 = [];
    protected $keyByteSize                   = self::DEFAULT_ENCRYPTION_KEY_BYTE_SIZE;
    protected $keyByteSizeMap                = [];
    protected $defaultByteSizeMapTypes       = ['ivByteSize','keyByteSize'];
    protected $vaultFile                     = null;
    protected $vaultRequestedSection         = null;
    protected $resultDataSet                 = [];
    protected $vaultReleaseType              = null;
    protected $vaultDefaultEnvironment       = null;
    protected $vaultEnvironment              = null;
    protected $vaultSection                  = null;
    protected $vaultId                       = null;
    protected $vaultUuid                     = null;
    protected $vaultDate                     = null;
    protected $vaultIsEncrypted              = null;
    protected $vaultEnvironments             = [];
    protected $vaultDefaultSection           = null;
    protected static $instance               = null;
    protected static $objectCount            = 0;
    protected $storageRegister               = [
        self::VAULTED  => [
            'payload'  => null,
            'method'   => null,
            'key'      => null,
            'option'   => null,
            'iv'       => null,
            'dataSize' => null,
            'ivSalt'   => null,
            'keySalt'  => null,
        ]
    ];

    //--------------------------------------------------------------------------

    /**
     * Constructor.
     *
     * @param FilesystemInterface $filesystem The FilesystemInterface
     * @param YamlInterface       $yaml       The YamlInterface
     *
     * @api
     */
    public function __construct(FilesystemInterface $filesystem, YamlInterface $yaml)
    {
        $this
            ->setProperty('yaml', $yaml)
            ->setProperty('filesystem', $filesystem)
            ->setAccountHomeDirectory() // location required
            ->setVaultSettingsDirectory() // location required
            ->setEncryptionSettingsFileName()
            ->loadEncryptionSettingsRawData()
            ->setHashidsProjectKey()
            ->loadHashids()
            ->setOpenSslVersion()
            ->setPrimaryHashArray()
            ->setCoreSeedHashArray()
            ->setInitializationVectorArray()
            ->setRsaPublicPrivateKeys()
            ->setAvailableOpenSslDigests()
            ->setAvailableOpenSslCipherMethods()
            ->setCipherMethod()
            ->setIvByteSize()
            ->setByteSizeMap('ivByteSize')
            ->setKeyByteSize()
            ->setByteSizeMap('keyByteSize')
            ->setOpenSslOption()
            ->setInitializationVector()
            ->setEncryptionKey();
    }

    //--------------------------------------------------------------------------

    /**
     * Decrypt a messages.
     *
     * Defaults to using Advanced Encryption Standard (AES), 256 bits
     * and any valid mode you may want to use.  Please reference the
     * defined DEFAULT_CIPHER_METHOD to see what is currently favored.
     *
     * @param string $payload The data payload to decrypt (includes iv)
     *
     * @return string The decrypted data
     *
     * @api
     */
    public function decrypt(string $payload): string
    {
        if (!is_callable('random_bytes')) {
            throw new \Exception('There is no suitable CSPRNG installed on your system');
        }

        /**
         * Default mode: \OPENSSL_RAW_DATA
         * Default method: AES-256-CTR
         * The iv should be unique to each encryption
         */
        $this->setInitializationVector($payload)->setEncryptionKey($payload);

        $decrypted = openssl_decrypt(
            base64_decode(substr($payload, self::THE_RAW_VAULT_DATA)),
            $this->get(self::VAULTED, 'method'),
            $this->get(self::VAULTED, 'key'),
            $this->get(self::VAULTED, 'option'),
            $this->get(self::VAULTED, 'iv')
        );

        return substr($decrypted, 0, $this->get(self::VAULTED, 'dataSize'));
    }

    //--------------------------------------------------------------------------

    /**
     * Encrypt a messages.
     *
     * Defaults to using Advanced Encryption Standard (AES), 256 bits
     * and any valid mode you may want to use.  Please reference the
     * defined DEFAULT_CIPHER_METHOD to see what is currently favored.
     *
     * @param string $payload The data payload to decrypt (includes iv)
     *
     * @return string The decrypted data
     *
     * @api
     */
    public function encrypt(string $payload): string
    {
        if (!is_callable('random_bytes')) {
            throw new \Exception('There is no suitable CSPRNG installed on your system');
        }

        /* The Ambit consists of: ['hash','dataSize,'ivSalt','keySalt'] */
        list($ambit, $payload) = [
            $this->renderAmbit($payload),
            sprintf('%s%s', $payload, $this->randomToken(self::DEFAULT_VAULT_SIZE - $this->stringSize($payload)))
        ];
        $this->setInitializationVector($ambit['hash'])->setEncryptionKey($ambit['hash']);

        /**
         * Default mode: \OPENSSL_RAW_DATA
         * Default method: AES-256-CTR
         * The iv should be unique to each encryption payload
         * maybe provide: $iv = base64_encode(random_bytes(openssl_cipher_iv_length($this->get(self::VAULTED, 'method'))));
         */
        return sprintf(
            '%s|%s',
            $ambit['hash'],
            base64_encode(openssl_encrypt(
                $payload,
                $this->get(self::VAULTED, 'method'),
                $this->get(self::VAULTED, 'key'),
                $this->get(self::VAULTED, 'option'),
                $this->get(self::VAULTED, 'iv')
            ))
        );
    }

    //--------------------------------------------------------------------------

    /**
     * Render the Ambit string.
     *
     * @param string $payload The string being encrypted
     *
     * @return string Returns the Ambit
     */
    protected function renderAmbit(string $payload): array
    {
        list($dataSize, $ivSalt, $keySalt) = [
            $this->stringSize($payload),
            $this->getRandomInt(),
            $this->getRandomInt()
        ];

        return [
            'hash'     => $this->hashids->encode([$dataSize, $ivSalt, $keySalt]),
            'dataSize' => $dataSize,
            'ivSalt'   => $ivSalt,
            'keySalt'  => $keySalt
        ];
    }

    //--------------------------------------------------------------------------

    /**
     * Provides the length of a string.
     *
     * @param string $payload The string being checked for length
     *
     * @return int Returns the number of characters
     */
    protected function stringSize(string $payload): int
    {
        return mb_strlen($payload, self::CHARSET);
    }

    //--------------------------------------------------------------------------

    /**
     * Set the option integer flag.
     *
     * @param int $option The bitwise disjunction used in OpenSSL (Default: 0, \OPENSSL_RAW_DATA: 1, \OPENSSL_ZERO_PADDING: 2)
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @api
     */
    public function setOpenSslOption(int $option = \OPENSSL_RAW_DATA): ConfigurationVaultInterface
    {
        return $this->set(self::VAULTED, $option, 'option');
    }

    //--------------------------------------------------------------------------

    /**
     * Set the Initialization Vector (IV).
     *
     * @param string $encoded The ciphered text
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @throws VaultException When an invalid method is provided
     *
     * @api
     */
    public function setEncryptionKey(string $encoded = null): ConfigurationVaultInterface
    {
        if ($encoded !== null && empty($this->hashidsDecode($encoded))) {
            throw new VaultException(sprintf('Invalid Hashids string was found "%s". This cannot be decoded into an array.', $encoded));
        }

        list($dataSize, $ivSalt, $keySalt) = empty($this->hashidsDecode($encoded)) ? null : $this->hashidsDecode($encoded);

        list($hash, $hours, $minutes, $seconds, $uuid) = [
            $this->getProperty('primaryHashArray', 'hash'),
            $this->getProperty('primaryHashArray', 'hours'),
            $this->getProperty('primaryHashArray', 'minutes'),
            $this->getProperty('primaryHashArray', 'seconds'),
            $this->getProperty('primaryHashArray', 'uuid')
        ];

        $unsizedKey = sha1(join([
            mb_substr($hash, $hours, $minutes, self::CHARSET),
            mb_substr($hash, (-1 * $seconds), null, self::CHARSET),
            $uuid,
            $keySalt
        ]));

        return $this
            ->set(self::VAULTED, base64_decode($this->resizeKeyToMap($unsizedKey, $this->keyByteSizeMap)), 'key')
                ->set(self::VAULTED, $keySalt, 'keySalt')
                    ->set(self::VAULTED, $dataSize, 'dataSize');
    }

    //--------------------------------------------------------------------------

    /**
     * Set the Initialization Vector (IV).
     *
     * @param string $encoded The ciphered text
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @throws VaultException When an invalid method is provided
     *
     * @api
     */
    public function setInitializationVector(string $encoded = null): ConfigurationVaultInterface
    {
        if ($encoded !== null && empty($this->hashidsDecode($encoded))) {
            throw new VaultException(sprintf('Invalid Hashids string was found "%s". This cannot be decoded into an array.', $encoded));
        }

        list($dataSize, $ivSalt, $keySalt) = empty($this->hashidsDecode($encoded)) ? null : $this->hashidsDecode($encoded);

        list($hash, $hours, $minutes, $seconds, $uuid) = [
            $this->getProperty('initializationVectorArray', 'hash'),
            $this->getProperty('initializationVectorArray', 'hours'),
            $this->getProperty('initializationVectorArray', 'minutes'),
            $this->getProperty('initializationVectorArray', 'seconds'),
            $this->getProperty('initializationVectorArray', 'uuid')
        ];

        $unsizedKey = sha1(join([
            mb_substr($hash, $hours, $minutes, self::CHARSET),
            mb_substr($hash, (-1 * $seconds), null, self::CHARSET),
            $uuid,
            $ivSalt
        ]));

        return $this
            ->set(self::VAULTED, base64_decode($this->resizeKeyToMap($unsizedKey, $this->ivByteSizeMap)), 'iv')
                ->set(self::VAULTED, $dataSize, 'dataSize')
                    ->set(self::VAULTED, $ivSalt, 'ivSalt')
                        ->set(self::VAULTED, $keySalt, 'keySalt');
    }

    //--------------------------------------------------------------------------

    /**
     * Resize the IV Key.
     *
     * @param array  $specificMapSize The map size parameters
     * @param string $hash            The hash to size
     *
     * @return string The hash sized correctly
     *
     * @api
     */
    protected function resizeKeyToMap(string $hash, array $specificMapSize): string
    {
        return sprintf('%s%s', mb_substr($hash, 0, $specificMapSize[0], self::CHARSET), $this->repeatString('=', $specificMapSize[1]));
    }

    //--------------------------------------------------------------------------

    /**
     * Get the Initialization Vector (IV) character map size.
     *
     * @param string $keyType              The key type to set (either: 'ivByteSize', 'keyByteSize')
     * @param int    $cipherMethodByteSize The initialization vector (iv) byte size
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @api
     */
    protected function setByteSizeMap(string $keyType = 'ivByteSize', int $cipherMethodByteSize = null): ConfigurationVaultInterface
    {
        /* check against a defined whitelist */
        if (!in_array($keyType, array_values($this->defaultByteSizeMapTypes), true)) {
            throw new VaultException(sprintf(
                'Invalid Byte Size Type was requested "%s". Check the predefined byte types for your current OpenSSL methods: %s',
                $keyType,
                $this->defaultByteSizeMapTypes
            ));
        }

        $cipherMethodByteSize =
        $cipherMethodByteSize === null
            ? $this->getProperty($keyType)
            : $cipherMethodByteSize;

        return $this->setProperty(
            sprintf('%s%s', $keyType, 'Map'),
            $this
                ->loadHashids($this->hashidsProjectKey, self::DEFAULT_MIN_HASHIDS_MAP_STEPS)
                    ->hashids->decode(mb_substr(
                        $this->getProperty('initializationVectorArray', 'map'),
                        (($cipherMethodByteSize -1) * self::DEFAULT_MIN_HASHIDS_MAP_STEPS),
                        self::DEFAULT_MIN_HASHIDS_MAP_STEPS
                    ))
        )->loadHashids();
    }

    //--------------------------------------------------------------------------

    /**
     * Hashids encode.
     *
     * @param int|string|array $numerical The numerical integer or array to encoded
     *
     * @return string The encoded hashid
     *
     * @api
     */
    public function hashidsEncode($numerical = null): string
    {
        return $this->hashids->encode($numerical);
    }

    //--------------------------------------------------------------------------

    /**
     * Hashids decode.
     *
     * @param string $id        The id string to decode
     * @param int    $starting  The option to define a starting point in the hash
     * @param int    $minLength The option to define a minimum padding length of the ids
     *
     * @return array|null The decoded id
     *
     * @api
     */
    public function hashidsDecode(string $id = null, int $starting = 0, int $minLength = self::DEFAULT_MIN_HASHIDS_LENGTH)
    {
        return $id === null ? null : $this->hashids->decode(mb_substr($id, $starting, $minLength, self::CHARSET));
    }

    //--------------------------------------------------------------------------

    /**
     * Load a new Hashid into memory.
     *
     * @param string $projectKey The option to define a project name to make your ids unique
     * @param int    $minLength  The option to define a minimum padding length of the ids
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @api
     */
    public function loadHashids(string $projectKey = null, int $minLength = self::DEFAULT_MIN_HASHIDS_LENGTH): ConfigurationVaultInterface
    {
        return $this->setProperty('hashids', new Hashids(($projectKey === null ? $this->getProperty('hashidsProjectKey') : $projectKey), $minLength));
    }

    //--------------------------------------------------------------------------

    /**
     * Set the RSA Private and Public Keys.
     *
     * @return ConfigurationVaultInterface The current instance
     */
    protected function setRsaPublicPrivateKeys(): ConfigurationVaultInterface
    {
        list($release, $environment) = [
            $this->encryptionSettingsRawData['type'], // encryption
            $this->encryptionSettingsRawData['default_environment'] // private
        ];

        return $this
            ->setProperty(
                'rsaPrivateKey4096',
                $this->encryptionSettingsRawData[$release][$environment]['private_key_4096']['data']
            )
            ->setProperty(
                'rsaPublicKey4096',
                $this->encryptionSettingsRawData[$release][$environment]['public_key_4096']['data']
            );
    }

    //--------------------------------------------------------------------------

    /**
     * Set the Encryption Key Byte Size (as determined by the cipher method used in OpenSSL).
     *
     * @param int $size The size in bytes for the key
     *
     * @return ConfigurationVaultInterface The current instance
     */
    protected function setKeyByteSize(int $size = self::DEFAULT_ENCRYPTION_KEY_BYTE_SIZE): ConfigurationVaultInterface
    {
        if (!$size) {
            throw new \Exception(sprintf(
                'Byte size was not found or invalid cipher method was requested. Check available cipher methods for your current OpenSSL version: %s',
                $this->openSslVersion
            ));
        }

        return $this->setProperty('keyByteSize', $size);
    }

    //--------------------------------------------------------------------------

    /**
     * Set the initialization vector (iv) Byte Size (as determined by the cipher method used in OpenSSL).
     *
     * @return ConfigurationVaultInterface The current instance
     */
    protected function setIvByteSize(): ConfigurationVaultInterface
    {
        $ivByteSize = openssl_cipher_iv_length($this->cipherMethod);

        if (!$ivByteSize) {
            throw new \Exception(sprintf(
                'Byte size was not found or invalid cipher method was requested. Check available cipher methods for your current OpenSSL version: %s',
                $this->openSslVersion
            ));
        }

        return $this->setProperty('ivByteSize', $ivByteSize);
    }

    //--------------------------------------------------------------------------

    /**
     * Set the cipher method used to encrypt/decrypt OpenSSL payloads.
     *
     * @param string $method The cipher method used to encrypt/decrypt the payload (Default: 'AES-256-CTR','AES-256-GCM','AES-256-CCM',etc.)
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @throws VaultException When an invalid method is provided
     *
     * @api
     */
    public function setCipherMethod(string $method = self::DEFAULT_CIPHER_METHOD): ConfigurationVaultInterface
    {
        /* check against a defined whitelist */
        if (!in_array($method, array_values($this->availableOpenSslCipherMethods), true)) {
            throw new VaultException(sprintf(
                'Invalid cipher method was requested "%s". Check available cipher methods for your current OpenSSL version: %s',
                $method,
                $this->openSslVersion
            ));
        }

        return $this->setProperty('cipherMethod', $method)->set(self::VAULTED, $method, 'method');
    }

    //--------------------------------------------------------------------------

    /**
     * Set OpenSSL version number.
     *
     * @return ConfigurationVaultInterface The current instance
     */
    protected function setOpenSslVersion(): ConfigurationVaultInterface
    {
        return $this->setProperty('openSslVersion', \OPENSSL_VERSION_TEXT);
    }

    //--------------------------------------------------------------------------

    /**
     * Set the list of available digest methods in the current version of PHP's OpenSSL.
     *
     * @param bool $aliases The option to include digest aliases in results
     *
     * @return ConfigurationVaultInterface The current instance
     */
    protected function setAvailableOpenSslDigests(bool $aliases = false): ConfigurationVaultInterface
    {
        return $this->setProperty('availableOpenSslDigests', openssl_get_md_methods($aliases));
    }

    //--------------------------------------------------------------------------

    /**
     * Set the list of available cipher methods in the current version of PHP's OpenSSL.
     *
     * @param bool $aliases The option to include cipher aliases in results
     *
     * @return ConfigurationVaultInterface The current instance
     */
    protected function setAvailableOpenSslCipherMethods(bool $aliases = false): ConfigurationVaultInterface
    {
        return $this->setProperty('availableOpenSslCipherMethods', openssl_get_cipher_methods($aliases));
    }

    //--------------------------------------------------------------------------

    /**
     * Set the core seed hash as an array
     *
     * @return ConfigurationVaultInterface The current instance
     */
    protected function setCoreSeedHashArray(): ConfigurationVaultInterface
    {
        list($release, $environment) = [
            $this->encryptionSettingsRawData['type'], // encryption
            $this->encryptionSettingsRawData['default_environment'] // private
        ];

        list($hash, $uuid, $date) = [
            join($this->encryptionSettingsRawData[$release][$environment]['core_seed_hash']['data']),
            trim($this->encryptionSettingsRawData[$release][$environment]['core_seed_hash']['uuid']),
            trim($this->encryptionSettingsRawData[$release][$environment]['core_seed_hash']['date'])
        ];

        list($date, $time) = explode(' ', $date);
        list($hours, $minutes, $seconds) = array_map('intval', explode(':', $time));

        return $this
            ->setProperty('coreSeedHashArray', $hash, 'hash')
                ->setProperty('coreSeedHashArray', $hours, 'hours')
                    ->setProperty('coreSeedHashArray', $minutes, 'minutes')
                        ->setProperty('coreSeedHashArray', $seconds, 'seconds')
                            ->setProperty('coreSeedHashArray', $uuid, 'uuid');
    }

    //--------------------------------------------------------------------------

    /**
     * Set the initialization vector as an array
     *
     * @return ConfigurationVaultInterface The current instance
     */
    protected function setInitializationVectorArray(): ConfigurationVaultInterface
    {
        list($release, $environment) = [
            $this->encryptionSettingsRawData['type'], // encryption
            $this->encryptionSettingsRawData['default_environment'] // private
        ];

        list($hash, $uuid, $date, $map) = [
            join($this->encryptionSettingsRawData[$release][$environment]['initialization_vector']['data']),
            trim($this->encryptionSettingsRawData[$release][$environment]['initialization_vector']['uuid']),
            trim($this->encryptionSettingsRawData[$release][$environment]['initialization_vector']['date']),
            join($this->encryptionSettingsRawData[$release][$environment]['initialization_vector']['map'])
        ];

        list($date, $time) = explode(' ', $date);
        list($hours, $minutes, $seconds) = array_map('intval', explode(':', $time));

        return $this
            ->setProperty('initializationVectorArray', $hash, 'hash')
                ->setProperty('initializationVectorArray', $map, 'map')
                    ->setProperty('initializationVectorArray', $hours, 'hours')
                        ->setProperty('initializationVectorArray', $minutes, 'minutes')
                            ->setProperty('initializationVectorArray', $seconds, 'seconds')
                                ->setProperty('initializationVectorArray', $uuid, 'uuid');
    }

    //--------------------------------------------------------------------------

    /**
     * Set the primary hash as an array
     *
     * @return ConfigurationVaultInterface The current instance
     */
    protected function setPrimaryHashArray(): ConfigurationVaultInterface
    {
        list($release, $environment) = [
            $this->encryptionSettingsRawData['type'], // encryption
            $this->encryptionSettingsRawData['default_environment'] // private
        ];

        list($hash, $uuid, $date) = [
            join($this->encryptionSettingsRawData[$release][$environment]['primary_hash']['data']),
            trim($this->encryptionSettingsRawData[$release][$environment]['primary_hash']['uuid']),
            trim($this->encryptionSettingsRawData[$release][$environment]['primary_hash']['date'])
        ];

        list($date, $time) = explode(' ', $date);
        list($hours, $minutes, $seconds) = array_map('intval', explode(':', $time));

        return $this
            ->setProperty('primaryHashArray', $hash, 'hash')
                ->setProperty('primaryHashArray', $hours, 'hours')
                    ->setProperty('primaryHashArray', $minutes, 'minutes')
                        ->setProperty('primaryHashArray', $seconds, 'seconds')
                            ->setProperty('primaryHashArray', $uuid, 'uuid');
    }

    //--------------------------------------------------------------------------

    /**
     * Set the Hashids Project Key.
     *
     * @param string $optional The option to use your own seed for the Hashids Key
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @api
     */
    public function setHashidsProjectKey(string $optional = null): ConfigurationVaultInterface
    {
        list($release, $environment) = [
            $this->encryptionSettingsRawData['type'], // encryption
            $this->encryptionSettingsRawData['default_environment'] // private
        ];

        list($hash, $uuid, $date) = [
            join($this->encryptionSettingsRawData[$release][$environment]['hashids']['data']),
            trim($this->encryptionSettingsRawData[$release][$environment]['hashids']['uuid']),
            trim($this->encryptionSettingsRawData[$release][$environment]['hashids']['date'])
        ];

        list($date, $time) = explode(' ', $date);
        list($hours, $minutes, $seconds) = array_map('intval', explode(':', $time));

        $this->setProperty(
            'hashidsProjectKey',
            $optional === null
                ? sha1(join([mb_substr($hash, $hours, $minutes, self::CHARSET), mb_substr($hash, (-1 * $seconds), null, self::CHARSET), $uuid]))
                : $optional
        );

        return $this;
    }

    //--------------------------------------------------------------------------

    /**
     * Load the Encryption Settings File Information to Array.
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @throws IOException When target does not exist or is unreadable
     */
    protected function loadEncryptionSettingsRawData(): ConfigurationVaultInterface
    {
        /* we check that target exists and is readable */
        if (!$this->isReadable($this->encryptionSettingsFileName)) {
            throw new IOException(
                sprintf('Cannot read the target file "%s". Does not exists or maybe unreadable.', $this->encryptionSettingsFileName),
                0,
                null,
                $this->encryptionSettingsFileName
            );
        }

        return $this->setProperty(
            'encryptionSettingsRawData',
            $this->yaml->deserialize($this->filesystem->read($this->encryptionSettingsFileName))
        );
    }

    //--------------------------------------------------------------------------

    /**
     * Tells whether a file exists and is readable.
     *
     * @param string $filename Path to the file
     *
     * @return bool
     *
     * @throws IOException When windows path is longer than 258 characters
     */
    protected function isReadable(string $filename): bool
    {
        if ('\\' === \DIRECTORY_SEPARATOR && strlen($filename) > 258) {
            throw new IOException('Could not check if file is readable because path length exceeds 258 characters.', 0, null, $filename);
        }

        return is_readable($filename);
    }

    //--------------------------------------------------------------------------

    /**
     * Set the Vault Settings File Name (e.g., '/home/jdeere/.external-configuration-settings/encryption-settings.yml').
     *
     * @param string $vaultFile The name of the Vault Settings File to use
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @throws FileNotFoundException When the vault file is missing or is not a file
     *
     * @api
     */
    public function setEncryptionSettingsFileName(string $vaultFile = null): ConfigurationVaultInterface
    {
        $vaultFilePath = sprintf('%s/%s', $this->getProperty('vaultSettingsDirectory'), $vaultFile);

        if ($vaultFile !== null && !$this->exists($vaultFilePath)) {
            throw new FileNotFoundException(sprintf('Failed to read "%s" because this file does not exist at this path location.', $vaultFilePath), 0, null, $vaultFilePath);
        }

        if ($vaultFile !== null && !is_file($vaultFilePath)) {
            throw new FileNotFoundException(sprintf('The Vault file "%s" is not a file. Please recheck the file path or filename.', $vaultFilePath), 0, null, $vaultFilePath);
        }

        return $this->setProperty(
            'encryptionSettingsFileName',
            $vaultFile === null
                ? realpath(sprintf('%s/%s', $this->getProperty('vaultSettingsDirectory'), static::ENCRYPTION_SETTINGS_FILE_NAME))
                : realpath($vaultFilePath)
        );
    }

    //--------------------------------------------------------------------------

    /**
     * Check the existance of files or directories.
     *
     * @param string|array|\Traversable $files The filename, array of files, or \Traversable.
     *
     * @return bool
     *
     * @api
     */
    public function exists($files): bool
    {
        foreach ($this->toIterator($files) as $file) {
            if ('\\' === \DIRECTORY_SEPARATOR && strlen($file) > 258) {
                throw new IOException('Could not check if file exist because path length exceeds 258 characters.', 0, null, $file);
            }

            if (!file_exists($file)) {
                return false;
            }
        }

        return true;
    }

    //--------------------------------------------------------------------------

    /**
     * Return as PHP Traversable Instance.
     *
     * {@see https://webmozart.io/blog/2012/10/07/give-the-traversable-interface-some-love/}
     *
     * @param mixed $files The string, array, object.
     *
     * @return \Traversable
     */
    protected function toIterator($files): \Traversable
    {
        if (!$files instanceof \Traversable) {
            $files = new \ArrayObject(is_array($files) ? $files : array($files));
        }

        return $files;
    }

    //--------------------------------------------------------------------------

    /**
     * Set the location of the Vault Settings Directory.
     *
     * The Vault Settings Directory is defined as the directory location outside of the
     * document root directory (or active webspace) where the configuration files
     * will exist (e.g., '/home/jdeere/.external-configuration-settings/').
     *
     * In many cases, the vault settings directory may exist within the unix user's account home directory.
     *
     * @param string $directoryPath The absolute path to the Vault Settings Directory (i.e., a hidden location)
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @throws IOException on invalid directory path
     *
     * @api
     */
    public function setVaultSettingsDirectory(string $directoryPath = null): ConfigurationVaultInterface
    {
        if ($directoryPath !== null && !is_dir($directoryPath)) {
            throw new IOException(
                sprintf('The directory path %s does not exist. Please check the input parameter on method: %s.', $directoryPath, __METHOD__),
                0,
                null,
                $directoryPath
            );
        }

        return $this->setProperty(
            'vaultSettingsDirectory',
            $directoryPath === null ? realpath(sprintf('%s/../%s', $_SERVER['DOCUMENT_ROOT'], static::VAULT_DIRECTORY_NAME)) : realpath($directoryPath)
        );
    }

    //--------------------------------------------------------------------------

    /**
     * Set the location of the Account Home Directory.
     *
     * The Account Home Directory is defined as the location where the unix user account
     * exists (e.g., '/home/jdeere').  This is a location that exist outside or one level above
     * the document root directory (i.e., above public_html).
     *
     * @param string $directoryPath The absolute path to the Account Home Directory (i.e., not document root)
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @throws IOException on invalid directory path
     *
     * @api
     */
    public function setAccountHomeDirectory(string $directoryPath = null): ConfigurationVaultInterface
    {
        if ($directoryPath !== null && !is_dir($directoryPath)) {
            throw new IOException(
                sprintf('The directory path %s does not exist. Please check the input parameter on method: %s.', $directoryPath, __METHOD__),
                0,
                null,
                $directoryPath
            );
        }

        return $this->setProperty(
            'accountHomeDirectory',
            $directoryPath === null ? realpath(sprintf('%s/../', $_SERVER['DOCUMENT_ROOT'])) : realpath($directoryPath)
        );
    }

    //--------------------------------------------------------------------------

    /**
     * Reverse a string.
     *
     * @param string $payload The string to be reversed
     *
     * @return string The reversed string.
     *
     * @api
     */
    public function reverseString(string $payload): string
    {
        return strrev($payload);
    }

    //--------------------------------------------------------------------------

    /**
     * Repeat a string.
     *
     * @param string $str    The string to be repeated
     * @param int    $number The number of time the string should be repeated
     *
     * @return string The repeated string.
     *
     * @api
     */
    public function repeatString(string $str, int $number): string
    {
        return str_repeat($str, $number);
    }

    //--------------------------------------------------------------------------

    /**
     * Convert string to number.
     *
     * Converts every byte into its decimal number equivalent, zero-padding
     * it to a fixed length of 3 digits so it can be unambiguously converted back.
     *
     * @param string $payload The data to encode
     *
     * @return string The data as a string of numbers
     *
     * @api
     */
    public function stringToNumber(string $payload): string
    {
        return join(array_map(
            function ($n) {
                return sprintf('%03d', $n);
            },
            unpack('C*', $payload)
        ));
    }

    //--------------------------------------------------------------------------

    /**
     * Convert numbers to string.
     *
     * Converts the zero-padded decimal number (3-digit) back to it's
     * character equivalent created by stringToNumber(string $payload)
     *
     * @param string $payload The data to decode
     *
     * @return string The string conversion
     *
     * @api
     */
    public function numberToString(string $payload): string
    {
        return join(array_map('chr', str_split($payload, 3)));
    }

    //--------------------------------------------------------------------------

    /**
     * Return a SHA-512 hash (CSPRNG Requires PHP v7.x).
     *
     * @param string $data    The string to translate
     * @param bool   $isUpper The option to modify case [upper, lower]
     *
     * @return string The hash string (128-characters)
     *
     * @api
     */
    public function getSha512(string $data = null, bool $isUpper = true): string
    {
        if (!is_callable('random_bytes')) {
            throw new \Exception('There is no suitable CSPRNG installed on your system');
        }

        $data = null === $data ? $this->getUniqueId() : $data;

        return true === $isUpper
            ? strtoupper(hash('sha512', $data))
            : hash('sha512', $data);
    }

    //--------------------------------------------------------------------------

    /**
     * Return a unique id (CSPRNG Requires PHP v7.x).
     *
     * @param int $length The byte length
     *
     * @return string The ASCII string containing the hexadecimal of the input string
     *
     * @api
     */
    public function getUniqueId(int $length = 16): string
    {
        if (!is_callable('random_bytes')) {
            throw new \Exception('There is no suitable CSPRNG installed on your system');
        }

        /* Create string of cryptographic random bytes */
        return bin2hex(random_bytes($length));
    }

    //--------------------------------------------------------------------------

    /**
     * Get a random token string (CSPRNG Requires PHP v7.x).
     *
     * @param int $length The length of the token
     * @param string $chars The string characters to use for the token
     *
     * @return string The random token string
     */
    protected function randomToken(int $length = 32, string $chars = self::PASSWORD_TOKENS): string
    {
        if (!is_callable('random_bytes')) {
            throw new \Exception('There is no suitable CSPRNG installed on your system');
        }

        list($bytes, $count, $result) = [random_bytes($length), strlen($chars), null];

        foreach (str_split($bytes) as $byte) {
            $result .= $chars[ord($byte) % $count];
        }

        return $result;
    }

    //--------------------------------------------------------------------------

    /**
     * Get a random hex string (CSPRNG Requires PHP v7.x).
     *
     * @param int $length The length of the token
     *
     * @return string The random token string
     *
     * @api
     */
    public function getRandomHex(int $length = 32): string
    {
        if (!is_callable('random_bytes')) {
            throw new \Exception('There is no suitable CSPRNG installed on your system');
        }

        return bin2hex(random_bytes($length/2));
    }

    //--------------------------------------------------------------------------

    /**
     * Open a selected configuration file.
     *
     * @param string $vaultFileDesignator   The specific configuration to open. (e.g., 'Database', 'SMTP', 'Account', 'Administrator', etc.)
     * @param string $vaultRequestedSection The requested section of the vault/settings file (e.g., 'webadmin', 'webuser', 'wwwdyn', etc.)
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @api
     */
    public function openVaultFile(string $vaultFileDesignator, string $vaultRequestedSection = null): ConfigurationVaultInterface
    {
        /* Extract the raw YAML file into array and store in $this->resultDataSet */
        $this->setVaultFile($vaultFileDesignator);
        $this->setVaultRequestedSection($vaultRequestedSection);
        $this->loadVaultSettingsFile();
        $this->setVaultEnvironmentTypeSettings();

        null === $this->getProperty('vaultRequestedSection')
            ? $this->setRecordProperties($this->vaultReleaseType, $this->vaultEnvironment)
                ->setVaultRecordEncrypted(false)
            : $this->setRecordProperties($this->vaultReleaseType, $this->vaultEnvironment, $this->vaultSection)
                ->setVaultRecordEncrypted($this->getProperty('resultDataSet')['is_encrypted']);

        /* Removing the last four elements from the array */
        return null === $this->getProperty('vaultRequestedSection')
            ? $this->setVaultDataArguments(
                array_keys($this->getProperty('resultDataSet')),
                $this->getProperty('resultDataSet')
            )
            : $this->setVaultDataArguments(
                array_slice(array_keys($this->getProperty('resultDataSet')), 0, count(array_keys($this->getProperty('resultDataSet'))) - 4),
                $this->getProperty('resultDataSet')
            );
    }

    //--------------------------------------------------------------------------

    /**
     * Set ConfigurationVault to encryption mode.
     *
     * @param bool $value The option to work with encrypted configuration data
     *
     * @return ConfigurationVaultInterface The current instance
     */
    protected function setVaultRecordEncrypted($value = true): ConfigurationVaultInterface
    {
        return $this->setProperty('vaultIsEncrypted', (bool) $value);
    }

    //--------------------------------------------------------------------------

    /**
     * Set the database record properties.
     *
     * @param string $vaultReleaseType The release collection type (e.g., 'database', 'account', 'smtp') as specified within the vault file
     * @param string $vaultEnvironment The current environment defined and used for a vault file (e.g., 'development', 'staging', 'production')
     * @param string $vaultSection     The specific section of the vault/settings file to be processed or opened (e.g., 'webadmin', 'webuser', 'wwwdyn', etc.)
     *
     * @return ConfigurationVaultInterface The current instance
     */
    public function setRecordProperties(string $vaultReleaseType, string $vaultEnvironment, string $vaultSection = null): ConfigurationVaultInterface
    {
        return null === $vaultSection
            ? $this->setProperty('resultDataSet', $this->getProperty('resultDataSet')[$vaultReleaseType][$vaultEnvironment])
            : $this
            ->setProperty('resultDataSet', $this->getProperty('resultDataSet')[$vaultReleaseType][$vaultEnvironment][$vaultSection])
                ->setProperty('vaultId', $this->getProperty('resultDataSet', 'id'))
                    ->setProperty('vaultUuid', $this->getProperty('resultDataSet', 'uuid'))
                        ->setProperty('vaultDate', $this->getProperty('resultDataSet', 'date'))
                            ->setVaultRecordEncrypted($this->getProperty('resultDataSet', 'is_encrypted'));
    }

    //--------------------------------------------------------------------------

    /**
     * Returns bool status of property $vaultIsEncrypted.
     *
     * @return bool
     */
    protected function isVaultRecordEncrypted(): bool
    {
        return $this->getProperty('vaultIsEncrypted');
    }

    //--------------------------------------------------------------------------

    /**
     * Set the environment type settings.
     *
     * @return ConfigurationVaultInterface The current instance
     */
    protected function setVaultEnvironmentTypeSettings(): ConfigurationVaultInterface
    {
        /* The release collection type (e.g., 'database', 'account', 'smtp') */
        $this->setProperty('vaultReleaseType', $this->getProperty('resultDataSet', 'type'));

        /* The current environment defined and used for a vault file (e.g.,'development','staging','production') */
        $this->setProperty(
            'vaultEnvironment',
            null !== $this->getProperty('vaultDefaultEnvironment')
                ? $this->getProperty('vaultDefaultEnvironment')
                : $this->getProperty('resultDataSet', 'default_environment')
        );

        /* The specific section of the vault/settings file to be processed (e.g., 'webadmin', 'webuser', 'wwwdyn', etc.) */
        return $this->setProperty('vaultSection', $this->getProperty('vaultRequestedSection'));
    }

    //--------------------------------------------------------------------------

    /**
     * Load the Vault Settings File Information to Array.
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @throws IOException When target does not exist or is unreadable
     */
    public function loadVaultSettingsFile(): ConfigurationVaultInterface
    {
        /* we check that target exists and is readable */
        if (!$this->isReadable($this->vaultFile)) {
            throw new IOException(
                sprintf('Cannot read the target file "%s". Does not exists or maybe unreadable.', $this->vaultFile),
                0,
                null,
                $this->vaultFile
            );
        }

        return $this->setProperty(
            'resultDataSet',
            $this->yaml->deserialize($this->filesystem->read($this->vaultFile))
        );
    }

    //--------------------------------------------------------------------------

    /**
     * Set the default specific section of the settings file.
     *
     * @param string $vaultRequestedSection The requested section of the vault/settings file (e.g., 'webadmin', 'webuser', 'wwwdyn', etc.)
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @api
     */
    public function setVaultRequestedSection(string $vaultRequestedSection = null): ConfigurationVaultInterface
    {
        return $this->setProperty(
            'vaultRequestedSection',
            '' === trim((string)$vaultRequestedSection)
                ? null
                : trim($vaultRequestedSection)
        );
    }

    //--------------------------------------------------------------------------

    /**
     * Set the vault filename to open.
     *
     * @param string $vaultFileDesignator The specific configuration to open. (e.g., 'Database', 'SMTP', 'Account', 'Administrator', 'Encryption')
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @throws VaultException When an invalid filename is created
     */
    public function setVaultFile(string $vaultFileDesignator): ConfigurationVaultInterface
    {
        $filename = false !== strpos($vaultFileDesignator, 'configuration-settings')
            ? sprintf('%s/%s.yml', $this->getProperty('vaultSettingsDirectory'), strtolower(trim($vaultFileDesignator, '/ ')))
            : sprintf('%s/%s%s.yml', $this->getProperty('vaultSettingsDirectory'), 'configuration-settings-', strtolower(trim($vaultFileDesignator, '/ ')));

        if (!realpath($filename)) {
            throw new VaultException(sprintf(
                'The parameters provided (file name: %s) does not exist or is not a valid file path. Please provide a real filename. Method: %s.',
                $filename,
                __METHOD__
            ));
        }

        return $this->setProperty('vaultFile', $filename);
    }

    //--------------------------------------------------------------------------

    /**
     * Generates cryptographically secure pseudo-random integers (CSPRNG Requires PHP v7.x).
     *
     * @param int $min The lowest value to be returned, which must be PHP_INT_MIN or higher
     * @param int $max The highest value to be returned, which must be less than or equal to PHP_INT_MAX.
     *
     * @return int A cryptographically secure random integer in a range min-to-max
     *
     * @throws VaultException When an invalid max value is provided
     *
     * @api
     */
    public function getRandomInt(int $min = self::MIN_RANDOM_INT, int $max = self::MAX_RANDOM_INT): int
    {
        if (!is_callable('random_bytes')) {
            throw new \Exception('There is no suitable CSPRNG installed on your system');
        }

        if ($max < $min) {
            throw new VaultException(sprintf(
                'Maximum integer must not be less than minimum: Max is: %s, Min is: %s. (%s)',
                $max,
                $min,
                __METHOD__
            ));
        }

        return random_int($min, $max);
    }

    //--------------------------------------------------------------------------

    /**
     * Set any required vault file arguments.
     *
     * @param array $arguments The specific list of arguments to set
     * @param array $vaultData The raw dataset from the vault file (YAML)
     *
     * @return ConfigurationVaultInterface The current instance
     */
    protected function setVaultDataArguments(array $arguments, array $vaultData): ConfigurationVaultInterface
    {
        foreach ($arguments as $argument) {
            true === $this->isVaultRecordEncrypted()
                ? $this->set($argument, $this->decrypt($vaultData[$argument]))
                : $this->set($argument, $vaultData[$argument]);
        }

        $this->unsetRegister(self::VAULTED);

        /* Informational: non-encrypted properties of the record */
        return $this
            ->set('id', $this->getProperty('vaultId'))
                ->set('uuid', $this->getProperty('vaultUuid'))
                    ->set('date', $this->getProperty('vaultDate'))
                        ->set('is_encrypted', $this->getProperty('vaultIsEncrypted'));
    }

    //--------------------------------------------------------------------------

    /**
     * Unset a storageRegister element.
     *
     * @param string $key    The element name
     * @param string $subkey The element subkey name
     *
     * @return ConfigurationVaultInterface The current instance
     *
     * @api
     */
    public function unsetRegister(string $key, string $subkey = null): ConfigurationVaultInterface
    {
        if (null === $subkey) {
            unset($this->{'storageRegister'}[$key]);
        } else {
            unset($this->{'storageRegister'}[$key][$subkey]);
        }

        return $this;
    }

    //--------------------------------------------------------------------------

    /**
     * Encrypt a message.
     *
     * Defaults to using Advanced Encryption Standard (AES), 256 bits
     * and any valid mode you may want to use.  Please reference the
     * defined DEFAULT_CIPHER_METHOD to see what is currently favored.
     *
     * @param string $payload       The data payload to encrypt
     * @param string $encryptionKey The encryption key
     * @param string $method        The cipher method used (e.g.,'AES-256-CTR','AES-256-GCM','AES-256-CCM', etc.)
     *
     * @return string The encrypted data
     *
     * @api
     */
    public function encryptMessage(string $payload, string $encryptionKey, string $method = 'aes-256-cbc'): string
    {
        /* Remove the base64 encoding from our key */
        $encryptionKey = base64_decode($encryptionKey);

        /* Generate an initialization vector */
        $iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length($method));

        /* Encrypt the data using AES 256 encryption in CBC mode using our encryption key and initialization vector. */
        $encrypted = openssl_encrypt($payload, $method, $encryptionKey, 0, $iv);
        unset($payload, $method, $encryptionKey);

        /* The $iv is just as important as the key for decrypting, so save it with our encrypted data using a unique separator (|) */
        return base64_encode($encrypted . '|' . $iv);
    }

    //--------------------------------------------------------------------------

    /**
     * Decrypt a messages.
     *
     * Defaults to using Advanced Encryption Standard (AES), 256 bits
     * and any valid mode you may want to use.  Please reference the
     * defined DEFAULT_CIPHER_METHOD to see what is currently favored.
     *
     * @param string $payload       The data payload to decrypt (includes iv)
     * @param string $encryptionKey The encryption key
     * @param string $method        The cipher method used (e.g.,'AES-256-CTR','AES-256-GCM','AES-256-CCM', etc.)
     *
     * @return string The decrypted data
     *
     * @api
     */
    public function decryptMessage(string $payload, string $encryptionKey, string $method = 'aes-256-cbc'): string
    {
        /* Remove the base64 encoding from our key */
        $encryptionKey = base64_decode($encryptionKey);

        /* To decrypt, split the encrypted data from our IV - our unique separator used was "|" */
        list($encrypted_data, $iv) = explode('|', base64_decode($payload), 2);
        $decryptedMessage = openssl_decrypt($encrypted_data, $method, $encryptionKey, 0, $iv);
        unset($payload, $method, $encryptionKey, $iv, $encrypted_data);

        return $decryptedMessage;
    }

    //--------------------------------------------------------------------------

    /**
     * Destructor.
     *
     * @api
     */
    public function __destruct()
    {
        static::$objectCount--;
    }

    //--------------------------------------------------------------------------

    /**
     * Method implementations inserted:
     *
     * Method list: (+) @api, (-) protected or private visibility.
     *
     * (+) array all();
     * (+) object init();
     * (+) string version();
     * (+) bool isString($str);
     * (+) bool has(string $key);
     * (+) string getClassName();
     * (+) int getInstanceCount();
     * (+) array getClassInterfaces();
     * (+) mixed getConst(string $key);
     * (+) bool isValidUuid(string $uuid);
     * (+) bool isValidEmail(string $email);
     * (+) bool isValidSHA512(string $hash);
     * (+) mixed __call($callback, $parameters);
     * (+) bool doesFunctionExist($functionName);
     * (+) bool isStringKey(string $str, array $keys);
     * (+) mixed get(string $key, string $subkey = null);
     * (+) mixed getProperty(string $name, string $key = null);
     * (+) object set(string $key, $value, string $subkey = null);
     * (+) object setProperty(string $name, $value, string $key = null);
     * (-) Exception throwExceptionError(array $error);
     * (-) InvalidArgumentException throwInvalidArgumentExceptionError(array $error);
     */
    use ServiceFunctions;

    //--------------------------------------------------------------------------
}
